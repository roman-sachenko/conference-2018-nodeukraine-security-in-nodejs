#!/usr/bin/env node

const http = require('http');
const https = require('https');

const BASE_URL = process.env.BASE_URL || 'http://localhost:3000';

const makeRequest = (method, path, data = null) => {
  return new Promise((resolve, reject) => {
    const url = new URL(path, BASE_URL);
    const options = {
      hostname: url.hostname,
      port: url.port,
      path: `${url.pathname}${url.search}`,
      method,
      headers: {
        'Content-Type': 'application/json',
      },
    };

    const req = (url.protocol === 'https:' ? https : http).request(options, (res) => {
      let body = '';
      res.on('data', (chunk) => { body += chunk; });
      res.on('end', () => {
        try {
          const parsed = JSON.parse(body);
          resolve({ status: res.statusCode, data: parsed });
        } catch (e) {
          resolve({ status: res.statusCode, data: body });
        }
      });
    });

    req.on('error', reject);
    
    if (data) {
      req.write(JSON.stringify(data));
    }
    
    req.end();
  });
};

const memoryLeakAttack = async () => {
  console.log('üíæ Starting Memory Leak Attack...');
  console.log(`üìç Target: ${BASE_URL}/attacks/memory-leak/`);
  console.log('='.repeat(60));
  
  // Monitor memory usage
  const startMemory = process.memoryUsage();
  console.log('üìä Initial memory usage:');
  console.log(`   Heap used: ${(startMemory.heapUsed / 1024 / 1024).toFixed(2)} MB`);
  console.log(`   Heap total: ${(startMemory.heapTotal / 1024 / 1024).toFixed(2)} MB`);
  console.log(`   External: ${(startMemory.external / 1024 / 1024).toFixed(2)} MB`);
  console.log('');
  
  const memorySnapshots = [];
  const requestBatches = [10, 50, 100, 200, 500];
  
  for (let i = 0; i < requestBatches.length; i++) {
    const batchSize = requestBatches[i];
    console.log(`üîç Making ${batchSize} requests...`);
    
    const batchStartMemory = process.memoryUsage();
    const startTime = Date.now();
    
    try {
      // Make batch of requests
      const requests = [];
      for (let j = 0; j < batchSize; j++) {
        requests.push(makeRequest('GET', '/attacks/memory-leak/'));
      }
      
      const results = await Promise.all(requests);
      const endTime = Date.now();
      const batchEndMemory = process.memoryUsage();
      
      const batchTime = endTime - startTime;
      const batchMemoryDiff = batchEndMemory.heapUsed - batchStartMemory.heapUsed;
      
      memorySnapshots.push({
        batchSize,
        time: batchTime,
        memoryBefore: batchStartMemory.heapUsed,
        memoryAfter: batchEndMemory.heapUsed,
        memoryDiff: batchMemoryDiff,
        successCount: results.filter(r => r.status === 200).length
      });
      
      console.log(`   ‚úÖ Completed in ${batchTime}ms`);
      console.log(`   üìä Memory before: ${(batchStartMemory.heapUsed / 1024 / 1024).toFixed(2)} MB`);
      console.log(`   üìä Memory after: ${(batchEndMemory.heapUsed / 1024 / 1024).toFixed(2)} MB`);
      console.log(`   üìä Memory difference: ${(batchMemoryDiff / 1024 / 1024).toFixed(2)} MB`);
      console.log(`   üìä Successful requests: ${results.filter(r => r.status === 200).length}/${batchSize}`);
      console.log('');
      
    } catch (error) {
      console.log(`   ‚ùå Error in batch ${batchSize}: ${error.message}`);
      console.log('');
    }
    
    // Add delay between batches
    await new Promise(resolve => setTimeout(resolve, 1000));
  }
  
  // Final memory snapshot
  const finalMemory = process.memoryUsage();
  const totalMemoryDiff = finalMemory.heapUsed - startMemory.heapUsed;
  
  console.log('üìä Final memory usage:');
  console.log(`   Heap used: ${(finalMemory.heapUsed / 1024 / 1024).toFixed(2)} MB`);
  console.log(`   Heap total: ${(finalMemory.heapTotal / 1024 / 1024).toFixed(2)} MB`);
  console.log(`   External: ${(finalMemory.external / 1024 / 1024).toFixed(2)} MB`);
  console.log(`   Total memory increase: ${(totalMemoryDiff / 1024 / 1024).toFixed(2)} MB`);
  console.log('');
  
  // Analyze results
  console.log('üìà Memory Leak Analysis:');
  console.log('=' * 60);
  
  let hasMemoryLeak = false;
  let totalRequests = 0;
  
  memorySnapshots.forEach((snapshot, index) => {
    totalRequests += snapshot.batchSize;
    
    const memoryPerRequest = snapshot.memoryDiff / snapshot.batchSize;
    const status = memoryPerRequest > 1024 ? 'üö® HIGH' : memoryPerRequest > 100 ? '‚ö†Ô∏è  MEDIUM' : '‚úÖ LOW';
    
    console.log(`Batch ${index + 1} (${snapshot.batchSize} requests):`);
    console.log(`   Memory per request: ${(memoryPerRequest / 1024).toFixed(2)} KB`);
    console.log(`   Status: ${status}`);
    console.log('');
    
    if (memoryPerRequest > 1024) {
      hasMemoryLeak = true;
    }
  });
  
  console.log('=' * 60);
  
  if (hasMemoryLeak) {
    console.log('üö® MEMORY LEAK DETECTED!');
    console.log(`   The application is leaking memory at a rate of ${(totalMemoryDiff / totalRequests / 1024).toFixed(2)} KB per request.`);
    console.log('   This can lead to server crashes and denial of service.');
  } else if (totalMemoryDiff > 10 * 1024 * 1024) { // More than 10MB total increase
    console.log('‚ö†Ô∏è  POTENTIAL MEMORY ISSUE');
    console.log('   Significant memory increase detected, but not necessarily a leak.');
    console.log('   Monitor the application for sustained memory growth.');
  } else {
    console.log('‚úÖ No significant memory leak detected.');
    console.log('   Memory usage is within acceptable ranges.');
  }
  
  return hasMemoryLeak;
};

// Run if called directly
if (require.main === module) {
  memoryLeakAttack().catch(console.error);
}

module.exports = { memoryLeakAttack };
