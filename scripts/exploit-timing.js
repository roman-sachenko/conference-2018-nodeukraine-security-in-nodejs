#!/usr/bin/env node

const http = require("http");
const https = require("https");

const BASE_URL = process.env.BASE_URL || "http://localhost:3000";

const makeRequest = (method, path, data = null) => {
  return new Promise((resolve, reject) => {
    const url = new URL(path, BASE_URL);
    const options = {
      hostname: url.hostname,
      port: url.port,
      path: `${url.pathname}${url.search}`,
      method,
      headers: {
        "Content-Type": "application/json",
      },
    };

    const req = (url.protocol === "https:" ? https : http).request(
      options,
      (res) => {
        let body = "";
        res.on("data", (chunk) => {
          body += chunk;
        });
        res.on("end", () => {
          try {
            const parsed = JSON.parse(body);
            resolve({ status: res.statusCode, data: parsed });
          } catch (e) {
            resolve({ status: res.statusCode, data: body });
          }
        });
      }
    );

    req.on("error", reject);

    if (data) {
      req.write(JSON.stringify(data));
    }

    req.end();
  });
};

const timingAttack = async () => {
  console.log("â±ï¸ Starting Timing Attack...");
  console.log(`ğŸ“ Target: ${BASE_URL}/attacks/timing/`);
  console.log("=".repeat(60));

  // Generate the target string that the controller expects
  const targetString = "take a look to the sky just before you die, its the last time you will".repeat(100);
  console.log(`ğŸ¯ Target string length: ${targetString.length} characters`);
  console.log(`ğŸ¯ Target string starts with: "${targetString.substring(0, 50)}..."`);
  console.log("");

  // Test different password lengths and patterns
  const testCases = [
    { name: "Short password", password: "short", expected: "fast" },
    {
      name: "Medium password",
      password: "medium_length_password",
      expected: "medium",
    },
    {
      name: "Long password (100x)",
      password: "take a look to the sky just before you die, its the last time you will".repeat(100),
      expected: "slow",
    },
    {
      name: "Very long password (500x)",
      password: "take a look to the sky just before you die, its the last time you will".repeat(500),
      expected: "very slow",
    },
    {
      name: "Huge password (1000x)",
      password: "take a look to the sky just before you die, its the last time you will".repeat(1000),
      expected: "extremely slow",
    },
    {
      name: "Massive password (2000x)",
      password: "take a look to the sky just before you die, its the last time you will".repeat(2000),
      expected: "critical timing difference",
    },
    {
      name: "Different start (1000x) - should fail early",
      password: "different start".repeat(1000),
      expected: "fast (should fail early)",
    },
    {
      name: "Matching start but different end (1000x)",
      password: "take a look to the sky just before you die, its the last time you will".repeat(1000) + "X",
      expected: "slow then fast (fails at end)",
    },
    {
      name: "EXACT MATCH (100x) - should be slowest",
      password: targetString,
      expected: "slowest (full comparison)",
    },
    {
      name: "DIFFERENT FIRST CHAR (100x) - should be fastest",
      password: "X" + targetString.substring(1),
      expected: "fastest (fails immediately)",
    },
  ];

  const results = {
    bcrypt: [],
    charByChar: [],
  };

  console.log("ğŸ” Testing bcrypt comparison...\n");

  // Test bcrypt comparison
  for (const testCase of testCases) {
    console.log(`ğŸ“ Testing: ${testCase.name}`);
    console.log(`   Password length: ${testCase.password.length} characters`);

    const times = [];

    // Make multiple requests to get average timing
    for (let i = 0; i < 5; i++) {
      const startTime = Date.now();

      try {
        const result = await makeRequest("POST", "/attacks/timing/", {
          password: testCase.password,
          compareByChar: false,
        });

        const endTime = Date.now();
        const responseTime = endTime - startTime;

        times.push(responseTime);

        console.log(`   Request ${i + 1}: ${responseTime}ms`);
      } catch (error) {
        console.log(`   âŒ Error in request ${i + 1}: ${error.message}`);
      }

      // Add delay between requests
      await new Promise((resolve) => setTimeout(resolve, 200));
    }

    if (times.length > 0) {
      const avgTime = times.reduce((a, b) => a + b, 0) / times.length;
      const minTime = Math.min(...times);
      const maxTime = Math.max(...times);

      results.bcrypt.push({
        name: testCase.name,
        passwordLength: testCase.password.length,
        avgTime,
        minTime,
        maxTime,
        times,
      });

      console.log(`   ğŸ“Š Average time: ${avgTime.toFixed(2)}ms`);
      console.log(`   ğŸ“Š Min time: ${minTime}ms`);
      console.log(`   ğŸ“Š Max time: ${maxTime}ms`);
      console.log("");
    }
  }

  console.log("ğŸ” Testing character-by-character comparison...\n");

  // Test character-by-character comparison
  for (const testCase of testCases) {
    console.log(`ğŸ“ Testing: ${testCase.name}`);
    console.log(`   Password length: ${testCase.password.length} characters`);

    const times = [];

    // Make multiple requests to get average timing
    for (let i = 0; i < 5; i++) {
      const startTime = Date.now();

      try {
        const result = await makeRequest("POST", "/attacks/timing/", {
          password: testCase.password,
          compareByChar: true,
        });

        const endTime = Date.now();
        const responseTime = endTime - startTime;

        times.push(responseTime);

        console.log(`   Request ${i + 1}: ${responseTime}ms`);
      } catch (error) {
        console.log(`   âŒ Error in request ${i + 1}: ${error.message}`);
      }

      // Add delay between requests
      await new Promise((resolve) => setTimeout(resolve, 200));
    }

    if (times.length > 0) {
      const avgTime = times.reduce((a, b) => a + b, 0) / times.length;
      const minTime = Math.min(...times);
      const maxTime = Math.max(...times);

      results.charByChar.push({
        name: testCase.name,
        passwordLength: testCase.password.length,
        avgTime,
        minTime,
        maxTime,
        times,
      });

      console.log(`   ğŸ“Š Average time: ${avgTime.toFixed(2)}ms`);
      console.log(`   ğŸ“Š Min time: ${minTime}ms`);
      console.log(`   ğŸ“Š Max time: ${maxTime}ms`);
      console.log("");
    }
  }

  // Analyze results
  console.log("ğŸ“Š Timing Attack Analysis:");
  console.log("=" * 60);

  let hasTimingVulnerability = false;

  // Analyze bcrypt results
  console.log("ğŸ” Bcrypt Comparison:");
  if (results.bcrypt.length > 0) {
    const shortPassword = results.bcrypt.find(
      (r) => r.name === "Short password"
    );
    const longPassword = results.bcrypt.find(
      (r) => r.name === "Very long password"
    );

    if (shortPassword && longPassword) {
      const timeRatio = longPassword.avgTime / shortPassword.avgTime;
      const status = timeRatio > 2 ? "ğŸš¨ VULNERABLE" : "âœ… SECURE";

      console.log(`   Short vs Long password ratio: ${timeRatio.toFixed(2)}x`);
      console.log(`   Status: ${status}`);

      if (timeRatio > 2) {
        hasTimingVulnerability = true;
      }
    }
  }
  console.log("");

  // Analyze character-by-character results
  console.log("ğŸ” Character-by-Character Comparison:");
  if (results.charByChar.length > 0) {
    const shortPassword = results.charByChar.find(
      (r) => r.name === "Short password"
    );
    const longPassword = results.charByChar.find(
      (r) => r.name === "Very long password"
    );

    if (shortPassword && longPassword) {
      const timeRatio = longPassword.avgTime / shortPassword.avgTime;
      const status = timeRatio > 2 ? "ğŸš¨ VULNERABLE" : "âœ… SECURE";

      console.log(`   Short vs Long password ratio: ${timeRatio.toFixed(2)}x`);
      console.log(`   Status: ${status}`);

      if (timeRatio > 2) {
        hasTimingVulnerability = true;
      }
    }
  }
  console.log("");

  // Check for timing differences based on password similarity
  console.log("ğŸ¯ Password Similarity Analysis:");
  const matchingStart = results.charByChar.find(
    (r) => r.name === "Matching start"
  );
  const differentStart = results.charByChar.find(
    (r) => r.name === "Different start"
  );

  if (matchingStart && differentStart) {
    const timeRatio = matchingStart.avgTime / differentStart.avgTime;
    const status = timeRatio > 1.5 ? "ğŸš¨ VULNERABLE" : "âœ… SECURE";

    console.log(
      `   Matching vs Different start ratio: ${timeRatio.toFixed(2)}x`
    );
    console.log(`   Status: ${status}`);

    if (timeRatio > 1.5) {
      hasTimingVulnerability = true;
    }
  }

  console.log("=" * 60);

  if (hasTimingVulnerability) {
    console.log("ğŸš¨ TIMING ATTACK VULNERABILITY DETECTED!");
    console.log("   The application is vulnerable to timing attacks.");
    console.log(
      "   Attackers can use timing differences to guess passwords character by character."
    );
  } else {
    console.log("âœ… No timing attack vulnerability detected.");
    console.log(
      "   All comparison methods have consistent timing regardless of input."
    );
  }

  return hasTimingVulnerability;
};

// Run if called directly
if (require.main === module) {
  timingAttack().catch(console.error);
}

module.exports = { timingAttack };
